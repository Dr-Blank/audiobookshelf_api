// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of '../audio_meta_tags.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

AudioMetaTags _$AudioMetaTagsFromJson(Map<String, dynamic> json) {
  return _AudioMetaTags.fromJson(json);
}

/// @nodoc
mixin _$AudioMetaTags {
  String? get tagAlbum => throw _privateConstructorUsedError;
  String? get tagArtist => throw _privateConstructorUsedError;
  String? get tagGenre => throw _privateConstructorUsedError;
  String? get tagTitle => throw _privateConstructorUsedError;
  String? get tagTrack => throw _privateConstructorUsedError;
  String? get tagAlbumArtist => throw _privateConstructorUsedError;
  String? get tagDate => throw _privateConstructorUsedError;
  String? get tagComposer => throw _privateConstructorUsedError;
  String? get tagDescription => throw _privateConstructorUsedError;
  String? get tagEncoder => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AudioMetaTagsCopyWith<AudioMetaTags> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AudioMetaTagsCopyWith<$Res> {
  factory $AudioMetaTagsCopyWith(
          AudioMetaTags value, $Res Function(AudioMetaTags) then) =
      _$AudioMetaTagsCopyWithImpl<$Res, AudioMetaTags>;
  @useResult
  $Res call(
      {String? tagAlbum,
      String? tagArtist,
      String? tagGenre,
      String? tagTitle,
      String? tagTrack,
      String? tagAlbumArtist,
      String? tagDate,
      String? tagComposer,
      String? tagDescription,
      String? tagEncoder});
}

/// @nodoc
class _$AudioMetaTagsCopyWithImpl<$Res, $Val extends AudioMetaTags>
    implements $AudioMetaTagsCopyWith<$Res> {
  _$AudioMetaTagsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tagAlbum = freezed,
    Object? tagArtist = freezed,
    Object? tagGenre = freezed,
    Object? tagTitle = freezed,
    Object? tagTrack = freezed,
    Object? tagAlbumArtist = freezed,
    Object? tagDate = freezed,
    Object? tagComposer = freezed,
    Object? tagDescription = freezed,
    Object? tagEncoder = freezed,
  }) {
    return _then(_value.copyWith(
      tagAlbum: freezed == tagAlbum
          ? _value.tagAlbum
          : tagAlbum // ignore: cast_nullable_to_non_nullable
              as String?,
      tagArtist: freezed == tagArtist
          ? _value.tagArtist
          : tagArtist // ignore: cast_nullable_to_non_nullable
              as String?,
      tagGenre: freezed == tagGenre
          ? _value.tagGenre
          : tagGenre // ignore: cast_nullable_to_non_nullable
              as String?,
      tagTitle: freezed == tagTitle
          ? _value.tagTitle
          : tagTitle // ignore: cast_nullable_to_non_nullable
              as String?,
      tagTrack: freezed == tagTrack
          ? _value.tagTrack
          : tagTrack // ignore: cast_nullable_to_non_nullable
              as String?,
      tagAlbumArtist: freezed == tagAlbumArtist
          ? _value.tagAlbumArtist
          : tagAlbumArtist // ignore: cast_nullable_to_non_nullable
              as String?,
      tagDate: freezed == tagDate
          ? _value.tagDate
          : tagDate // ignore: cast_nullable_to_non_nullable
              as String?,
      tagComposer: freezed == tagComposer
          ? _value.tagComposer
          : tagComposer // ignore: cast_nullable_to_non_nullable
              as String?,
      tagDescription: freezed == tagDescription
          ? _value.tagDescription
          : tagDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      tagEncoder: freezed == tagEncoder
          ? _value.tagEncoder
          : tagEncoder // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AudioMetaTagsCopyWith<$Res>
    implements $AudioMetaTagsCopyWith<$Res> {
  factory _$$_AudioMetaTagsCopyWith(
          _$_AudioMetaTags value, $Res Function(_$_AudioMetaTags) then) =
      __$$_AudioMetaTagsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? tagAlbum,
      String? tagArtist,
      String? tagGenre,
      String? tagTitle,
      String? tagTrack,
      String? tagAlbumArtist,
      String? tagDate,
      String? tagComposer,
      String? tagDescription,
      String? tagEncoder});
}

/// @nodoc
class __$$_AudioMetaTagsCopyWithImpl<$Res>
    extends _$AudioMetaTagsCopyWithImpl<$Res, _$_AudioMetaTags>
    implements _$$_AudioMetaTagsCopyWith<$Res> {
  __$$_AudioMetaTagsCopyWithImpl(
      _$_AudioMetaTags _value, $Res Function(_$_AudioMetaTags) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tagAlbum = freezed,
    Object? tagArtist = freezed,
    Object? tagGenre = freezed,
    Object? tagTitle = freezed,
    Object? tagTrack = freezed,
    Object? tagAlbumArtist = freezed,
    Object? tagDate = freezed,
    Object? tagComposer = freezed,
    Object? tagDescription = freezed,
    Object? tagEncoder = freezed,
  }) {
    return _then(_$_AudioMetaTags(
      tagAlbum: freezed == tagAlbum
          ? _value.tagAlbum
          : tagAlbum // ignore: cast_nullable_to_non_nullable
              as String?,
      tagArtist: freezed == tagArtist
          ? _value.tagArtist
          : tagArtist // ignore: cast_nullable_to_non_nullable
              as String?,
      tagGenre: freezed == tagGenre
          ? _value.tagGenre
          : tagGenre // ignore: cast_nullable_to_non_nullable
              as String?,
      tagTitle: freezed == tagTitle
          ? _value.tagTitle
          : tagTitle // ignore: cast_nullable_to_non_nullable
              as String?,
      tagTrack: freezed == tagTrack
          ? _value.tagTrack
          : tagTrack // ignore: cast_nullable_to_non_nullable
              as String?,
      tagAlbumArtist: freezed == tagAlbumArtist
          ? _value.tagAlbumArtist
          : tagAlbumArtist // ignore: cast_nullable_to_non_nullable
              as String?,
      tagDate: freezed == tagDate
          ? _value.tagDate
          : tagDate // ignore: cast_nullable_to_non_nullable
              as String?,
      tagComposer: freezed == tagComposer
          ? _value.tagComposer
          : tagComposer // ignore: cast_nullable_to_non_nullable
              as String?,
      tagDescription: freezed == tagDescription
          ? _value.tagDescription
          : tagDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      tagEncoder: freezed == tagEncoder
          ? _value.tagEncoder
          : tagEncoder // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AudioMetaTags implements _AudioMetaTags {
  const _$_AudioMetaTags(
      {this.tagAlbum,
      this.tagArtist,
      this.tagGenre,
      this.tagTitle,
      this.tagTrack,
      this.tagAlbumArtist,
      this.tagDate,
      this.tagComposer,
      this.tagDescription,
      this.tagEncoder});

  factory _$_AudioMetaTags.fromJson(Map<String, dynamic> json) =>
      _$$_AudioMetaTagsFromJson(json);

  @override
  final String? tagAlbum;
  @override
  final String? tagArtist;
  @override
  final String? tagGenre;
  @override
  final String? tagTitle;
  @override
  final String? tagTrack;
  @override
  final String? tagAlbumArtist;
  @override
  final String? tagDate;
  @override
  final String? tagComposer;
  @override
  final String? tagDescription;
  @override
  final String? tagEncoder;

  @override
  String toString() {
    return 'AudioMetaTags(tagAlbum: $tagAlbum, tagArtist: $tagArtist, tagGenre: $tagGenre, tagTitle: $tagTitle, tagTrack: $tagTrack, tagAlbumArtist: $tagAlbumArtist, tagDate: $tagDate, tagComposer: $tagComposer, tagDescription: $tagDescription, tagEncoder: $tagEncoder)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AudioMetaTags &&
            (identical(other.tagAlbum, tagAlbum) ||
                other.tagAlbum == tagAlbum) &&
            (identical(other.tagArtist, tagArtist) ||
                other.tagArtist == tagArtist) &&
            (identical(other.tagGenre, tagGenre) ||
                other.tagGenre == tagGenre) &&
            (identical(other.tagTitle, tagTitle) ||
                other.tagTitle == tagTitle) &&
            (identical(other.tagTrack, tagTrack) ||
                other.tagTrack == tagTrack) &&
            (identical(other.tagAlbumArtist, tagAlbumArtist) ||
                other.tagAlbumArtist == tagAlbumArtist) &&
            (identical(other.tagDate, tagDate) || other.tagDate == tagDate) &&
            (identical(other.tagComposer, tagComposer) ||
                other.tagComposer == tagComposer) &&
            (identical(other.tagDescription, tagDescription) ||
                other.tagDescription == tagDescription) &&
            (identical(other.tagEncoder, tagEncoder) ||
                other.tagEncoder == tagEncoder));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      tagAlbum,
      tagArtist,
      tagGenre,
      tagTitle,
      tagTrack,
      tagAlbumArtist,
      tagDate,
      tagComposer,
      tagDescription,
      tagEncoder);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AudioMetaTagsCopyWith<_$_AudioMetaTags> get copyWith =>
      __$$_AudioMetaTagsCopyWithImpl<_$_AudioMetaTags>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AudioMetaTagsToJson(
      this,
    );
  }
}

abstract class _AudioMetaTags implements AudioMetaTags {
  const factory _AudioMetaTags(
      {final String? tagAlbum,
      final String? tagArtist,
      final String? tagGenre,
      final String? tagTitle,
      final String? tagTrack,
      final String? tagAlbumArtist,
      final String? tagDate,
      final String? tagComposer,
      final String? tagDescription,
      final String? tagEncoder}) = _$_AudioMetaTags;

  factory _AudioMetaTags.fromJson(Map<String, dynamic> json) =
      _$_AudioMetaTags.fromJson;

  @override
  String? get tagAlbum;
  @override
  String? get tagArtist;
  @override
  String? get tagGenre;
  @override
  String? get tagTitle;
  @override
  String? get tagTrack;
  @override
  String? get tagAlbumArtist;
  @override
  String? get tagDate;
  @override
  String? get tagComposer;
  @override
  String? get tagDescription;
  @override
  String? get tagEncoder;
  @override
  @JsonKey(ignore: true)
  _$$_AudioMetaTagsCopyWith<_$_AudioMetaTags> get copyWith =>
      throw _privateConstructorUsedError;
}
